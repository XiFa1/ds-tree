<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Christmas Tree (CN Mirror)</title>
    <style>
        /* --- æ ·å¼éƒ¨åˆ†ä¿æŒä¸å˜ --- */
        body { margin: 0; overflow: hidden; background-color: #020502; font-family: 'Helvetica Neue', Arial, sans-serif; user-select: none; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; }
        #input-video { position: absolute; bottom: 10px; right: 10px; width: 160px; height: 120px; z-index: 2; border: 2px solid #D4AF37; border-radius: 8px; opacity: 0.5; transform: scaleX(-1); display: block; }
        #ui-layer { position: absolute; top: 20px; left: 20px; z-index: 10; color: #D4AF37; pointer-events: none; }
        h1 { margin: 0; font-weight: 300; letter-spacing: 2px; text-transform: uppercase; text-shadow: 0 0 10px rgba(212, 175, 55, 0.5); }
        .status { font-size: 14px; color: #fff; margin-top: 10px; opacity: 0.8; }
        .instruction { margin-top: 20px; font-size: 12px; line-height: 1.6; color: #aaa; background: rgba(0,0,0,0.5); padding: 10px; border-left: 3px solid #b01b2e; border-radius: 0 5px 5px 0; }
        #controls { pointer-events: auto; margin-top: 20px; }
        input[type="file"] { display: none; }
        .btn { background: linear-gradient(135deg, #b01b2e, #8a0f1e); color: white; padding: 10px 20px; border: 1px solid #D4AF37; border-radius: 30px; cursor: pointer; font-size: 12px; text-transform: uppercase; letter-spacing: 1px; transition: all 0.3s ease; box-shadow: 0 0 15px rgba(176, 27, 46, 0.4); }
        .btn:hover { background: linear-gradient(135deg, #d42e44, #b01b2e); box-shadow: 0 0 25px rgba(176, 27, 46, 0.7); transform: scale(1.05); }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #D4AF37; font-size: 18px; z-index: 20; text-shadow: 0 0 20px #D4AF37; transition: opacity 0.5s; text-align: center; line-height: 1.5; }
    </style>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://npm.elemecdn.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://npm.elemecdn.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script src="https://npm.elemecdn.com/gsap@3.12.2/dist/gsap.min.js"></script>
    <script src="https://npm.elemecdn.com/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://npm.elemecdn.com/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://npm.elemecdn.com/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://npm.elemecdn.com/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">
        æ­£åœ¨è¿æ¥å›½å†…é•œåƒæº...<br>
        <span style="font-size:12px; color:#aaa;">é¦–æ¬¡åŠ è½½ AI æ¨¡å‹å¯èƒ½éœ€è¦ 10-20 ç§’ï¼Œè¯·ç¨å€™</span>
    </div>

    <div id="ui-layer">
        <h1>Xmas Particle System</h1>
        <div class="status">å½“å‰çŠ¶æ€: <span id="state-text">ç³»ç»Ÿå¯åŠ¨ä¸­...</span></div>
        
        <div class="instruction">
            <strong>æ‰‹åŠ¿æ§åˆ¶æŒ‡å—:</strong><br>
            âœŠ <b>æ¡æ‹³:</b> èšåˆ (åœ£è¯æ ‘)<br>
            ğŸ– <b>äº”æŒ‡å¼ å¼€:</b> æ•£å¼€ (æ¼‚æµ®)<br>
            ğŸ‘‹ <b>æ‰‹æŒç§»åŠ¨:</b> æ—‹è½¬è§†è§’ (æ•£å¼€æ—¶)<br>
            ğŸ‘Œ <b>æåˆ:</b> æŠ“å–ç…§ç‰‡æ”¾å¤§
        </div>

        <div id="controls">
            <label class="btn">
                ä¸Šä¼ ç…§ç‰‡
                <input type="file" id="upload-input" accept="image/*" multiple>
            </label>
        </div>
    </div>

    <video id="input-video"></video>
    <div id="canvas-container"></div>

    <script type="module">
        // é€šè¿‡ Import Map å¼•å…¥ Three.jsï¼Œæ— éœ€æ”¹åŠ¨è·¯å¾„
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- å…¨å±€é…ç½® ---
        const CONFIG = {
            particleCount: 400, 
            photoCount: 12,     
            colorPalette: [0x2F4F4F, 0x556B2F, 0xD4AF37, 0xB01B2E, 0xFFFFFF], 
            bloomParams: { threshold: 0, strength: 1.5, radius: 0.8 }
        };

        const STATES = { TREE: 'TREE', SCATTER: 'SCATTER', FOCUS: 'FOCUS' };
        let currentState = STATES.TREE;

        // --- Three.js åˆå§‹åŒ– ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x020502, 0.02);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 25;
        camera.position.y = 5;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        container.appendChild(renderer.domElement);

        // --- ç¯å…‰ç³»ç»Ÿ ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
        scene.add(ambientLight);
        const pointLight = new THREE.PointLight(0xD4AF37, 2, 50);
        pointLight.position.set(0, 10, 10);
        scene.add(pointLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(-5, 10, 5);
        scene.add(dirLight);

        // --- åå¤„ç† ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        Object.assign(bloomPass, CONFIG.bloomParams);
        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- å‡ ä½•ä½“ä¸æè´¨ ---
        const particles = []; 
        const photoMeshes = []; 
        const geometries = {
            sphere: new THREE.SphereGeometry(0.3, 32, 32),
            box: new THREE.BoxGeometry(0.5, 0.5, 0.5),
            capsule: new THREE.CapsuleGeometry(0.1, 1, 4, 8) 
        };
        const materials = {
            gold: new THREE.MeshStandardMaterial({ color: 0xD4AF37, metalness: 1.0, roughness: 0.1 }),
            matteGreen: new THREE.MeshStandardMaterial({ color: 0x2F4F4F, metalness: 0.1, roughness: 0.8 }),
            red: new THREE.MeshStandardMaterial({ color: 0xB01B2E, metalness: 0.3, roughness: 0.4 }),
            white: new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0x222222 })
        };

        // --- ç”Ÿæˆé€»è¾‘ ---
        function initParticleData(mesh, index, total) {
            const y = (index / total) * 16 - 8; 
            const radius = (1 - (y + 8) / 16) * 6; 
            const angle = index * 2.4; 
            
            mesh.userData = {
                treePos: {
                    x: Math.cos(angle) * radius,
                    y: y,
                    z: Math.sin(angle) * radius,
                    rx: Math.random() * Math.PI, ry: Math.random() * Math.PI, rz: Math.random() * Math.PI
                },
                scatterPos: {
                    x: (Math.random() - 0.5) * 30, y: (Math.random() - 0.5) * 30, z: (Math.random() - 0.5) * 20,
                    rx: Math.random() * Math.PI * 2, ry: Math.random() * Math.PI * 2, rz: Math.random() * Math.PI * 2
                },
                originalScale: mesh.geometry.type === 'PlaneGeometry' ? 1 : (0.5 + Math.random() * 0.5)
            };
            mesh.position.set(mesh.userData.treePos.x, mesh.userData.treePos.y, mesh.userData.treePos.z);
            mesh.scale.setScalar(mesh.userData.originalScale);
        }

        function createParticles() {
            for (let i = 0; i < CONFIG.particleCount; i++) {
                let mesh;
                const type = Math.random();
                if (type < 0.6) mesh = new THREE.Mesh(geometries.sphere, Math.random() > 0.5 ? materials.gold : materials.matteGreen);
                else if (type < 0.8) mesh = new THREE.Mesh(geometries.box, materials.red);
                else mesh = new THREE.Mesh(geometries.capsule, materials.white);
                initParticleData(mesh, i, CONFIG.particleCount);
                scene.add(mesh);
                particles.push(mesh);
            }
        }

        function createPhotoPlaceholders() {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#D4AF37'; ctx.fillRect(0,0,256,256);
            ctx.fillStyle = '#000'; ctx.font = '30px Arial'; ctx.textAlign = 'center'; ctx.fillText("PHOTO", 128, 128);
            const defaultTex = new THREE.CanvasTexture(canvas);

            for (let i = 0; i < CONFIG.photoCount; i++) {
                const mesh = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 2), new THREE.MeshBasicMaterial({ map: defaultTex, side: THREE.DoubleSide }));
                initParticleData(mesh, CONFIG.particleCount + i, CONFIG.particleCount + CONFIG.photoCount);
                scene.add(mesh);
                particles.push(mesh);
                photoMeshes.push(mesh);
            }
        }

        createParticles();
        createPhotoPlaceholders();

        // --- äº¤äº’ä¸åŠ¨ç”» ---
        function transitionTo(state, targetPhotoMesh = null) {
            if (currentState === state && state !== STATES.FOCUS) return;
            currentState = state;
            const stateEl = document.getElementById('state-text');
            
            if (state === STATES.TREE) {
                stateEl.innerText = "åœ£è¯æ ‘å½¢æ€ (Tree)";
                stateEl.style.color = "#2F4F4F";
                particles.forEach(p => {
                    gsap.to(p.position, { ...p.userData.treePos, duration: 1.5, ease: "power2.inOut" });
                    gsap.to(p.rotation, { x: p.userData.treePos.rx, y: p.userData.treePos.ry, z: p.userData.treePos.rz, duration: 1.5 });
                    gsap.to(p.scale, { x: p.userData.originalScale, y: p.userData.originalScale, z: p.userData.originalScale, duration: 1 });
                });
                gsap.to(scene.rotation, { x: 0, y: 0, duration: 1 });
            } else if (state === STATES.SCATTER) {
                stateEl.innerText = "æ•£å¼€æ¼‚æµ® (Scatter)";
                stateEl.style.color = "#D4AF37";
                particles.forEach(p => {
                    gsap.to(p.position, { ...p.userData.scatterPos, duration: 2, ease: "power3.out" });
                    gsap.to(p.rotation, { x: p.userData.scatterPos.rx, y: p.userData.scatterPos.ry, z: p.userData.scatterPos.rz, duration: 2 });
                    gsap.to(p.scale, { x: p.userData.originalScale, y: p.userData.originalScale, z: p.userData.originalScale, duration: 1 });
                });
            } else if (state === STATES.FOCUS && targetPhotoMesh) {
                stateEl.innerText = "ç…§ç‰‡å±•ç¤º (Focus)";
                stateEl.style.color = "#B01B2E";
                particles.forEach(p => {
                    if(p !== targetPhotoMesh) gsap.to(p.position, { x: p.userData.scatterPos.x * 1.5, y: p.userData.scatterPos.y * 1.5, z: p.userData.scatterPos.z - 5, duration: 1 });
                });
                gsap.to(targetPhotoMesh.position, { x: 0, y: 0, z: 15, duration: 1, ease: "back.out(1.7)" });
                gsap.to(targetPhotoMesh.rotation, { x: 0, y: 0, z: 0, duration: 1 });
                gsap.to(targetPhotoMesh.scale, { x: 3, y: 3, z: 3, duration: 1 });
            }
        }

        document.getElementById('upload-input').addEventListener('change', (e) => {
            const files = e.target.files;
            if (!files.length) return;
            const textureLoader = new THREE.TextureLoader();
            let fileIndex = 0;
            for(let i = 0; i < photoMeshes.length; i++) {
                if (fileIndex >= files.length) fileIndex = 0;
                const reader = new FileReader();
                const meshToUpdate = photoMeshes[i];
                reader.onload = (evt) => {
                    const img = new Image();
                    img.src = evt.target.result;
                    img.onload = () => {
                        const tex = textureLoader.load(img.src);
                        tex.colorSpace = THREE.SRGBColorSpace;
                        meshToUpdate.material.map = tex;
                        meshToUpdate.material.needsUpdate = true;
                    };
                };
                reader.readAsDataURL(files[fileIndex++]);
            }
            alert(`å·²åŠ è½½ ${files.length} å¼ ç…§ç‰‡`);
        });

        // --- MediaPipe ä¸ æ‘„åƒå¤´é€»è¾‘ ---
        const videoElement = document.getElementById('input-video');
        const loadingScreen = document.getElementById('loading');
        let lastGestureTime = 0;

        function onResults(results) {
            loadingScreen.style.opacity = '0';
            setTimeout(() => loadingScreen.style.display = 'none', 500);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                detectGesture(results.multiHandLandmarks[0]);
            }
        }

        // === å…³é”®ä¿®æ”¹ï¼šæŒ‡å®š locateFile ä½¿ç”¨å›½å†…é•œåƒ ===
        const hands = new Hands({locateFile: (file) => {
            return `https://npm.elemecdn.com/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7
        });
        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        });
        cameraUtils.start();

        function detectGesture(landmarks) {
            const now = Date.now();
            if (now - lastGestureTime < 500) return;

            const wrist = landmarks[0];
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            
            function dist(p1, p2) { return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2)); }
            
            const isIndexOpen = dist(indexTip, wrist) > 0.3;
            const isMiddleOpen = dist(landmarks[12], wrist) > 0.3;
            const isRingOpen = dist(landmarks[16], wrist) > 0.3;
            const isPinkyOpen = dist(landmarks[20], wrist) > 0.3;
            const openFingers = [isIndexOpen, isMiddleOpen, isRingOpen, isPinkyOpen].filter(Boolean).length;

            if (openFingers === 0) {
                transitionTo(STATES.TREE);
                lastGestureTime = now;
            } else if (openFingers >= 4) {
                transitionTo(STATES.SCATTER);
                if (currentState === STATES.SCATTER) {
                    gsap.to(scene.rotation, { x: (wrist.y - 0.5), y: (wrist.x - 0.5), duration: 1 });
                }
            }
            if (dist(thumbTip, indexTip) < 0.05 && currentState !== STATES.TREE) {
                const target = photoMeshes[Math.floor(Math.random() * photoMeshes.length)];
                transitionTo(STATES.FOCUS, target);
                lastGestureTime = now;
            }
        }

        // --- æ¸²æŸ“å¾ªç¯ ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            if (currentState === STATES.TREE) scene.rotation.y += 0.002;
            else if (currentState === STATES.SCATTER) {
                particles.forEach((p, i) => { p.position.y += Math.sin(clock.getElapsedTime() + i) * 0.005; });
            }
            composer.render();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
