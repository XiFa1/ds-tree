<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Controlled Christmas Particle System</title>
    <style>
        /* 1. åŸºç¡€æ ·å¼ä¸UIè®¾å®š */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #020502; /* æ·±é‚ƒçš„å¢¨ç»¿/é»‘èƒŒæ™¯ */
            font-family: 'Helvetica Neue', Arial, sans-serif;
            user-select: none;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        /* æ‘„åƒå¤´ç”»é¢ï¼ˆç”¨äºè°ƒè¯•ï¼Œé»˜è®¤éšè—ï¼Œå¯è®¾ä¸ºblockæŸ¥çœ‹ï¼‰ */
        #input-video {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 160px;
            height: 120px;
            z-index: 2;
            border: 2px solid #D4AF37; /* é‡‘å±é‡‘ */
            border-radius: 8px;
            opacity: 0.5;
            transform: scaleX(-1); /* é•œåƒç¿»è½¬ */
            display: block; 
        }

        /* UI è¦†ç›–å±‚ */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            color: #D4AF37;
            pointer-events: none; /* è®©é¼ æ ‡äº‹ä»¶ç©¿é€åˆ° Canvas */
        }

        h1 {
            margin: 0;
            font-weight: 300;
            letter-spacing: 2px;
            text-transform: uppercase;
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
        }

        .status {
            font-size: 14px;
            color: #fff;
            margin-top: 10px;
            opacity: 0.8;
        }

        .instruction {
            margin-top: 20px;
            font-size: 12px;
            line-height: 1.6;
            color: #aaa;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-left: 3px solid #b01b2e; /* åœ£è¯çº¢ */
            border-radius: 0 5px 5px 0;
        }

        /* ä¸Šä¼ æŒ‰é’®åŒºåŸŸ - å…è®¸ç‚¹å‡» */
        #controls {
            pointer-events: auto;
            margin-top: 20px;
        }

        input[type="file"] {
            display: none;
        }

        .btn {
            background: linear-gradient(135deg, #b01b2e, #8a0f1e);
            color: white;
            padding: 10px 20px;
            border: 1px solid #D4AF37;
            border-radius: 30px;
            cursor: pointer;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s ease;
            box-shadow: 0 0 15px rgba(176, 27, 46, 0.4);
        }

        .btn:hover {
            background: linear-gradient(135deg, #d42e44, #b01b2e);
            box-shadow: 0 0 25px rgba(176, 27, 46, 0.7);
            transform: scale(1.05);
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #D4AF37;
            font-size: 24px;
            z-index: 20;
            text-shadow: 0 0 20px #D4AF37;
            transition: opacity 0.5s;
        }
    </style>
    
    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://unpkg.com/three@0.160.0/examples/jsm/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.160.0/examples/jsm/shaders/CopyShader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">æ­£åœ¨åˆå§‹åŒ–è§†è§‰ç³»ç»Ÿä¸AIæ¨¡å‹...</div>

    <div id="ui-layer">
        <h1>Xmas Particle System</h1>
        <div class="status">å½“å‰çŠ¶æ€: <span id="state-text">åˆå§‹åŒ–ä¸­</span></div>
        
        <div class="instruction">
            <strong>æ‰‹åŠ¿æ§åˆ¶æŒ‡å—:</strong><br>
            âœŠ <b>æ¡æ‹³:</b> èšåˆ (åœ£è¯æ ‘æ¨¡å¼)<br>
            ğŸ– <b>äº”æŒ‡å¼ å¼€:</b> æ•£å¼€ (æ¼‚æµ®æ¨¡å¼)<br>
            ğŸ‘‹ <b>æ‰‹æŒç§»åŠ¨:</b> æ—‹è½¬è§†è§’ (æ•£å¼€æ¨¡å¼ä¸‹)<br>
            ğŸ‘Œ <b>æåˆ (OKæ‰‹åŠ¿):</b> æŠ“å–ç…§ç‰‡æ”¾å¤§
        </div>

        <div id="controls">
            <label class="btn">
                ä¸Šä¼ ç…§ç‰‡äº‘ç´ æ
                <input type="file" id="upload-input" accept="image/*" multiple>
            </label>
        </div>
    </div>

    <video id="input-video"></video>
    <div id="canvas-container"></div>

    <script type="module">
        import { EffectComposer } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js';

        // --- å…¨å±€é…ç½® ---
        const CONFIG = {
            particleCount: 400, // è£…é¥°ç‰©æ•°é‡
            photoCount: 12,     // é¢„ç•™ç…§ç‰‡ä½
            colorPalette: [0x2F4F4F, 0x556B2F, 0xD4AF37, 0xB01B2E, 0xFFFFFF], // å“‘å…‰ç»¿, æ©„æ¦„ç»¿, é‡‘è‰², çº¢è‰², ç™½è‰²
            bloomParams: {
                threshold: 0,
                strength: 1.5,
                radius: 0.8
            }
        };

        // --- çŠ¶æ€ç®¡ç† ---
        const STATES = {
            TREE: 'TREE',
            SCATTER: 'SCATTER',
            FOCUS: 'FOCUS'
        };
        let currentState = STATES.TREE;
        let targetRotationX = 0;
        let targetRotationY = 0;

        // --- Three.js åˆå§‹åŒ– ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        // å¢åŠ ä¸€ç‚¹ç¯å¢ƒé›¾æ°”ï¼Œè¥é€ ç”µå½±æ„Ÿ
        scene.fog = new THREE.FogExp2(0x020502, 0.02);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 25;
        camera.position.y = 5;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        container.appendChild(renderer.domElement);

        // --- ç¯å…‰ç³»ç»Ÿ ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xD4AF37, 2, 50);
        pointLight.position.set(0, 10, 10);
        scene.add(pointLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(-5, 10, 5);
        scene.add(dirLight);

        // --- åå¤„ç† (Glow/Bloom) ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = CONFIG.bloomParams.threshold;
        bloomPass.strength = CONFIG.bloomParams.strength;
        bloomPass.radius = CONFIG.bloomParams.radius;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- å¯¹è±¡ç®¡ç† ---
        const particles = []; // å­˜å‚¨æ‰€æœ‰ Mesh å¯¹è±¡
        const photoMeshes = []; // ä¸“é—¨å­˜å‚¨ç…§ç‰‡ Mesh
        const geometries = {
            sphere: new THREE.SphereGeometry(0.3, 32, 32),
            box: new THREE.BoxGeometry(0.5, 0.5, 0.5),
            capsule: new THREE.CapsuleGeometry(0.1, 1, 4, 8) // ç³–æœæ£
        };

        const materials = {
            gold: new THREE.MeshStandardMaterial({ color: 0xD4AF37, metalness: 1.0, roughness: 0.1 }),
            matteGreen: new THREE.MeshStandardMaterial({ color: 0x2F4F4F, metalness: 0.1, roughness: 0.8 }),
            red: new THREE.MeshStandardMaterial({ color: 0xB01B2E, metalness: 0.3, roughness: 0.4 }),
            white: new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0x222222 }),
            photo: new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide }) // å ä½
        };

        // --- ç²’å­/ç‰©ä½“ç”Ÿæˆç³»ç»Ÿ ---

        // 1. ç”Ÿæˆè£…é¥°ç‰© (çƒã€æ–¹å—ã€ç³–æœ)
        function createParticles() {
            for (let i = 0; i < CONFIG.particleCount; i++) {
                let mesh;
                const type = Math.random();
                
                if (type < 0.6) {
                    // 60% çƒä½“
                    const mat = Math.random() > 0.5 ? materials.gold : materials.matteGreen;
                    mesh = new THREE.Mesh(geometries.sphere, mat);
                } else if (type < 0.8) {
                    // 20% æ–¹å— (ç¤¼ç‰©ç›’)
                    mesh = new THREE.Mesh(geometries.box, materials.red);
                } else {
                    // 20% ç³–æœæ£
                    mesh = new THREE.Mesh(geometries.capsule, materials.white);
                }

                initParticleData(mesh, i, CONFIG.particleCount);
                scene.add(mesh);
                particles.push(mesh);
            }
        }

        // 2. ç”Ÿæˆç…§ç‰‡äº‘å ä½ç¬¦
        function createPhotoPlaceholders() {
            // åˆ›å»ºé»˜è®¤çº¹ç†
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#D4AF37';
            ctx.fillRect(0,0,256,256);
            ctx.fillStyle = '#000';
            ctx.font = '30px Arial';
            ctx.textAlign = 'center';
            ctx.fillText("PHOTO", 128, 128);
            const defaultTex = new THREE.CanvasTexture(canvas);

            for (let i = 0; i < CONFIG.photoCount; i++) {
                const geo = new THREE.PlaneGeometry(1.5, 2); // ç«–å‘ç…§ç‰‡æ¯”ä¾‹
                const mat = new THREE.MeshBasicMaterial({ map: defaultTex, side: THREE.DoubleSide });
                const mesh = new THREE.Mesh(geo, mat);
                
                // è®©ç…§ç‰‡åœ¨ç²’å­åˆ—è¡¨æœ«å°¾ï¼Œä¹Ÿå•ç‹¬å­˜ä¸€ä»½
                initParticleData(mesh, CONFIG.particleCount + i, CONFIG.particleCount + CONFIG.photoCount);
                scene.add(mesh);
                particles.push(mesh);
                photoMeshes.push(mesh);
            }
        }

        // --- æ ¸å¿ƒç®—æ³•ï¼šä½ç½®è®¡ç®— ---
        function initParticleData(mesh, index, total) {
            // 1. åœ£è¯æ ‘å½¢æ€ (åœ†é”¥èºæ—‹)
            const y = (index / total) * 16 - 8; // é«˜åº¦èŒƒå›´ -8 åˆ° 8
            const radius = (1 - (y + 8) / 16) * 6; // åº•éƒ¨åŠå¾„å¤§ï¼Œé¡¶éƒ¨å°
            const angle = index * 2.4; // é»„é‡‘è§’è¿‘ä¼¼ï¼Œäº§ç”Ÿèºæ—‹
            
            mesh.userData = {
                treePos: {
                    x: Math.cos(angle) * radius,
                    y: y,
                    z: Math.sin(angle) * radius,
                    rx: Math.random() * Math.PI,
                    ry: Math.random() * Math.PI,
                    rz: Math.random() * Math.PI
                },
                scatterPos: {
                    x: (Math.random() - 0.5) * 30,
                    y: (Math.random() - 0.5) * 30,
                    z: (Math.random() - 0.5) * 20,
                    rx: Math.random() * Math.PI * 2,
                    ry: Math.random() * Math.PI * 2,
                    rz: Math.random() * Math.PI * 2
                },
                originalScale: mesh.geometry.type === 'PlaneGeometry' ? 1 : (0.5 + Math.random() * 0.5)
            };

            // åˆå§‹ä½ç½®è®¾ä¸º Tree
            mesh.position.set(mesh.userData.treePos.x, mesh.userData.treePos.y, mesh.userData.treePos.z);
            mesh.scale.setScalar(mesh.userData.originalScale);
        }

        createParticles();
        createPhotoPlaceholders();

        // --- åŠ¨ç”»è½¬æ¢é€»è¾‘ (GSAP) ---
        function transitionTo(state, targetPhotoMesh = null) {
            if (currentState === state && state !== STATES.FOCUS) return;
            
            const stateEl = document.getElementById('state-text');
            currentState = state;

            if (state === STATES.TREE) {
                stateEl.innerText = "åœ£è¯æ ‘å½¢æ€ (Tree)";
                stateEl.style.color = "#2F4F4F";
                
                // å°†æ‰€æœ‰ç²’å­ç§»å›æ ‘çš„å½¢çŠ¶
                particles.forEach(p => {
                    gsap.to(p.position, {
                        x: p.userData.treePos.x,
                        y: p.userData.treePos.y,
                        z: p.userData.treePos.z,
                        duration: 1.5,
                        ease: "power2.inOut"
                    });
                    gsap.to(p.rotation, {
                        x: p.userData.treePos.rx,
                        y: p.userData.treePos.ry,
                        z: p.userData.treePos.rz,
                        duration: 1.5
                    });
                    gsap.to(p.scale, {
                        x: p.userData.originalScale,
                        y: p.userData.originalScale,
                        z: p.userData.originalScale,
                        duration: 1
                    });
                });
                // ç›¸æœºå¤ä½
                gsap.to(scene.rotation, { x: 0, y: 0, duration: 1 });

            } else if (state === STATES.SCATTER) {
                stateEl.innerText = "æ•£å¼€æ¼‚æµ® (Scatter)";
                stateEl.style.color = "#D4AF37";

                particles.forEach(p => {
                    gsap.to(p.position, {
                        x: p.userData.scatterPos.x,
                        y: p.userData.scatterPos.y,
                        z: p.userData.scatterPos.z,
                        duration: 2,
                        ease: "power3.out"
                    });
                    gsap.to(p.rotation, {
                        x: p.userData.scatterPos.rx,
                        y: p.userData.scatterPos.ry,
                        z: p.userData.scatterPos.rz,
                        duration: 2
                    });
                    gsap.to(p.scale, {
                        x: p.userData.originalScale,
                        y: p.userData.originalScale,
                        z: p.userData.originalScale,
                        duration: 1
                    });
                });

            } else if (state === STATES.FOCUS && targetPhotoMesh) {
                stateEl.innerText = "ç…§ç‰‡å±•ç¤º (Focus)";
                stateEl.style.color = "#B01B2E";

                // å…¶ä»–ç²’å­æ¨å¼€
                particles.forEach(p => {
                    if(p !== targetPhotoMesh) {
                        // ç®€å•çš„æ¨å¼€é€»è¾‘ï¼šå¦‚æœç¦»ä¸­å¿ƒå¤ªè¿‘ï¼Œå¾€å¤–æ¨
                        gsap.to(p.position, {
                            x: p.userData.scatterPos.x * 1.5, 
                            y: p.userData.scatterPos.y * 1.5,
                            z: p.userData.scatterPos.z - 5, // èƒŒæ™¯åé€€
                            duration: 1
                        });
                    }
                });

                // ç›®æ ‡ç…§ç‰‡ç§»åˆ°ä¸­é—´å¹¶æ”¾å¤§
                gsap.to(targetPhotoMesh.position, {
                    x: 0, y: 0, z: 15, // é è¿‘ç›¸æœº
                    duration: 1,
                    ease: "back.out(1.7)"
                });
                gsap.to(targetPhotoMesh.rotation, {
                    x: 0, y: 0, z: 0,
                    duration: 1
                });
                gsap.to(targetPhotoMesh.scale, {
                    x: 3, y: 3, z: 3,
                    duration: 1
                });
            }
        }

        // --- ç…§ç‰‡ä¸Šä¼ å¤„ç† ---
        document.getElementById('upload-input').addEventListener('change', (e) => {
            const files = e.target.files;
            if (!files.length) return;

            const textureLoader = new THREE.TextureLoader();
            let fileIndex = 0;

            // å¾ªç¯æ›´æ–°ç°æœ‰çš„ç…§ç‰‡Mesh
            for(let i = 0; i < photoMeshes.length; i++) {
                if (fileIndex >= files.length) fileIndex = 0; // å¾ªç¯ä½¿ç”¨å›¾ç‰‡
                
                const reader = new FileReader();
                const meshToUpdate = photoMeshes[i];
                const file = files[fileIndex];

                reader.onload = (evt) => {
                    const img = new Image();
                    img.src = evt.target.result;
                    img.onload = () => {
                        const tex = textureLoader.load(img.src);
                        tex.colorSpace = THREE.SRGBColorSpace;
                        meshToUpdate.material.map = tex;
                        meshToUpdate.material.needsUpdate = true;
                    };
                };
                reader.readAsDataURL(file);
                fileIndex++;
            }
            alert(`å·²åŠ è½½ ${files.length} å¼ ç…§ç‰‡åˆ°ç²’å­äº‘ä¸­`);
        });

        // --- MediaPipe Hands é›†æˆ ---
        const videoElement = document.getElementById('input-video');
        const loadingScreen = document.getElementById('loading');
        let lastGestureTime = 0;
        
        function onResults(results) {
            loadingScreen.style.opacity = '0'; // éšè—åŠ è½½å±‚
            setTimeout(() => loadingScreen.style.display = 'none', 500);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                detectGesture(landmarks);
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7
        });
        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });
        cameraUtils.start();

        // --- æ‰‹åŠ¿è¯†åˆ«é€»è¾‘ ---
        function detectGesture(landmarks) {
            const now = Date.now();
            if (now - lastGestureTime < 500) return; // é˜²æŠ–åŠ¨ (500ms)

            // å…³é”®ç‚¹ç´¢å¼•: 
            // 0: æ‰‹è…•, 4: æ‹‡æŒ‡å°–, 8: é£ŸæŒ‡å°–, 12: ä¸­æŒ‡å°–, 16: æ— åæŒ‡å°–, 20: å°æŒ‡å°–
            
            // è®¡ç®—æ‰‹æŒ‡å°–åˆ°æ‰‹è…•çš„è·ç¦»ï¼Œåˆ¤æ–­æ‰‹æŒ‡æ˜¯å¦å¼¯æ›²
            const wrist = landmarks[0];
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const middleTip = landmarks[12];
            const ringTip = landmarks[16];
            const pinkyTip = landmarks[20];

            function dist(p1, p2) {
                return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
            }

            const isThumbOpen = dist(thumbTip, wrist) > 0.2; // æ‹‡æŒ‡æ¯”è¾ƒç‰¹æ®Š
            const isIndexOpen = dist(indexTip, wrist) > 0.3;
            const isMiddleOpen = dist(middleTip, wrist) > 0.3;
            const isRingOpen = dist(ringTip, wrist) > 0.3;
            const isPinkyOpen = dist(pinkyTip, wrist) > 0.3;

            const openFingers = [isIndexOpen, isMiddleOpen, isRingOpen, isPinkyOpen].filter(Boolean).length;

            // 1. æ¡æ‹³ (Fist): æ‰€æœ‰æ‰‹æŒ‡å¼¯æ›²
            if (openFingers === 0) {
                transitionTo(STATES.TREE);
                lastGestureTime = now;
                return;
            }

            // 2. äº”æŒ‡å¼ å¼€ (Open Palm): è‡³å°‘4æŒ‡å¼ å¼€
            if (openFingers >= 4) {
                transitionTo(STATES.SCATTER);
                
                // 3. æ—‹è½¬é€»è¾‘ (ä»…åœ¨ Scatter æ¨¡å¼ä¸‹ç”Ÿæ•ˆ)
                if (currentState === STATES.SCATTER) {
                    // ä½¿ç”¨æ‰‹è…•ä½ç½®æ§åˆ¶æ—‹è½¬
                    // x: 0-1, y: 0-1. ä¸­å¿ƒæ˜¯ 0.5
                    const rotX = (wrist.y - 0.5) * 2; // -1 to 1
                    const rotY = (wrist.x - 0.5) * 2; // -1 to 1
                    
                    // å¹³æ»‘æ’å€¼æ—‹è½¬
                    gsap.to(scene.rotation, {
                        x: rotX * 0.5,
                        y: rotY * 0.5,
                        duration: 1
                    });
                }
                // ä¸è¦é‡ç½® lastGestureTimeï¼Œå…è®¸è¿ç»­æ—‹è½¬
                return; 
            }

            // 4. æåˆ/OKæ‰‹åŠ¿ (Pinch): æ‹‡æŒ‡å’Œé£ŸæŒ‡éå¸¸è¿‘ï¼Œå…¶ä»–æ‰‹æŒ‡å¼ å¼€
            // ç”¨äºæŠ“å–ç…§ç‰‡
            const pinchDist = dist(thumbTip, indexTip);
            if (pinchDist < 0.05 && currentState !== STATES.TREE) {
                // éšæœºé€‰ä¸€å¼ ç…§ç‰‡æˆ–é€‰æœ€ä¸­é—´çš„
                const target = photoMeshes[Math.floor(Math.random() * photoMeshes.length)];
                transitionTo(STATES.FOCUS, target);
                lastGestureTime = now;
            }
        }

        // --- æ¸²æŸ“å¾ªç¯ ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            
            // è‡ªåŠ¨è‡ªè½¬ (ä»…åœ¨ Tree æ¨¡å¼ä¸‹)
            if (currentState === STATES.TREE) {
                scene.rotation.y += 0.002;
            } else if (currentState === STATES.SCATTER) {
                // æ¼‚æµ®åŠ¨ç”»
                particles.forEach((p, i) => {
                    p.position.y += Math.sin(clock.getElapsedTime() + i) * 0.005;
                });
            }

            // å¿…è¦çš„æ›´æ–°
            composer.render();
        }

        // çª—å£å¤§å°è°ƒæ•´
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>

